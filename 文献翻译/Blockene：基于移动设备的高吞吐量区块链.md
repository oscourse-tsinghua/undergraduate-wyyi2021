# Blockene：基于移动设备的高吞吐量区块链

## 摘要

我们推出了Blockene，这种区块链能够使成员节点处的资源消耗减少多个数量级，并且仅通过一部智能手机就可以参与区块验证和共识机制。尽管Blockene是轻量级的，它依然可以为大量的参与者提供高吞吐量的交易与测量。Blockene在智能手机上的电量、数据消耗都是微不足道的，这使得数百万的用户得以在没有奖励机制的情况下就能够加入到区块链中、能够通过他们的集体诚信保证交易的安全性。Blockene通过一个全新的信任分割设计实现以上特性，这种设计基于委托式存储以及对不可信节点的流言传播。

通过原型实现，我们看到Blockene可支持每秒1045个交易的吞吐量，并且在智能手机上以使用极少的资源运行；这为搭建安全、去中心化的应用提供了一个新的范式。

## 1 简介

区块链提供了一个强大的系统抽象：它们使得互相不信任的实体（成员）可以以去中心化的方式集体管理交易的分类账。

当今所有的区块链都需要成员节点运行能力强大且带有充足网络、存储和计算资源的服务器。基于工作量证明机的区块量需要极大的计算量来解决难题，从而将资源使用推向了一个极端；但即便是联盟链和基于权益证明的区块链也需要承担高额的网络和存储成本以保证在高吞吐量的交易下，区块链内容是最新的。因此，当今的区块链仅限于用户有强烈动机参与的情况，因为这样他们才可以负担得起高昂的资源成本，比如，在联盟链中经营效率可以得到提高，而在加密数字货币中成员们可以赚取通货。

有趣的是，区块链对资源的高需求同时也会削弱一些实际应用的可靠性。区块链要求大部分（通常是三分之二）的成员是诚信的，当有大量成员参与时这一属性比较容易得到保证。但是考虑到对资源的高需求，区块链很难被广泛采用，特别是在成员们没有直接参与动机的情况下。当下拥有成员较多的公共区块链面向加密数字货币，也是不足为奇的。

在这篇文章中，我们提出了Blockene，一种超轻量、大规模、为实际交易提供高吞吐量的区块链。由于其轻量级和可扩展性，它能够被数百位用户广泛使用；通过对大规模参与的支持，Blockene使得多数诚实的假设变得合理；其高吞吐量保证Blockene能够支持现实中的交易速率。

Blockene的关键突破点在于，它不会要求成员运行强大的服务器，相反地，它是第一个允许成员以一等公民的身份参与共识机制的区块链，即便在轻量如智能手机的设备上运行也是如此，从而将成本降低了多个数量级。

**网络：**区块链依赖于成员间点对点的八卦交流；在高吞吐量下，信息交流需要每日几十GB的数据传输来完成；Blockene只需要智能手机上约每日60MB的数据传输。

**存储：**区块链中的成员节点上维护一份整条区块链的副本（在高吞吐量下可达到几兆兆字节）；在Blockene中，成员只需要承担几百MB的存储。

**计算：**仅仅是常见区块链的信息交流成本就足以耗光移动节点的电池电量；Blockene可以保证电池消耗少于每日3%。

因此，用户在运行Blockene时不会产生显著的成本消耗。其低资源使用情况使得Blockene甚至可以在智能手机上运行，因此它也同样可以在台式电脑上运行，使用的资源要远远少于当下的先进技术。

Blockene实现了三个相互冲突的属性：大规模参与、高吞吐量以及轻量级的资源使用，它甚至迎合了没有直接激励的场景（例如利他主义分享），并能够处理跨越各种用例（包括公共资金）的交易。表1对Blockene与其他区块链架构进行了比较。

**实例应用：审计慈善事业。**全球范围内，每年对非盈利组织的慈善捐款超过了5000亿美元。但是从捐献者的角度来看，资金的最终用途缺少透明度，这使得捐款容易受到非营利组织的欠佳使用或不当管理，特别是在监管执法效率低下或参与腐败的地区中。一个提供从捐助方到最终受益方的、公开的端对端资金追踪的系统，除了激励捐助者之外，也会对非盈利组织施加市场压力。区块链可以提供这样的追踪，但是考虑到涉及到的资金规模，将区块链的维护交由一个由成员组成的小联盟是不可信的。理想情况下，这样一个区块链应当由数百万成员无私地共同控制着。类似的要求也出现在政府或公共开支中。

**Blockene中的关键技术：**Blockene采用了一个新颖的、基于信任分割架构和全新安全模型的系统设计。Blockene中有两种类型的节点：公民与政治家。公民节点在智能手机上运行，并且是区块链的实际成员，即他们在共识协议中拥有投票权利；由此我们假设三分之二的公民是诚实的（当有数百万的公民时该假设是合理的）。另一方面，政治家节点在服务器上运行并且是不可信的，即他们不参与共识机制。政治家在数量上更少（几百或几千），同时我们只要求他们之中有20%是诚实的。虽然是政治家们来完成诸如存储区块链的繁重工作，我们的协议确保公民可以检测并处理恶意行为，即便是80%的政治家和三分之一的恶意公民进行了串通。公民们使用一种叫做“复制可验证阅读”的原语来应对政治家的高欺骗率：公民从多个政治家处读取相同的数据，即便其中（比如说，在25个之中）只有一个是诚实的，也可以得到正确的数值。

公民通过运行拜占庭共识进行交易验证，并决定要提交的区块和全局结果状态。为了使共识在数百万公民参与下保持可信，Blockene借鉴了一个来自Algorand的想法（进行了修改，使其更加节电），其中由（约2000个）公民组成的不同的随机委员会被加密选中，为每个区块运行共识。与Algorand不同的是，Blockene会在委员会成员参与工作前几分钟曝光他们的身份：这使得Blockene能够在公民节点处减少数据和电池成本。尽管这看起来为针对委员会的攻击提供了更大的窗口，我们在$\S 4.2$中讨论了为什么这不是一个严重的问题。

为了使公民节点处的存储、交流成本保持在较低水平，只有政治家节点存储区块链和全局状态（即键值对），让公民节点从所有区块的八卦（约50GB/天）中解脱出来。公民只从政治家处读取一小部分数据（例如当前区块交易的键值），然后写出新的区块。进一步地，由于政治家是不可信的，公民不能依赖地认为他们根据给定键值返回的最新值是正确的。Blockene使用了一种新技术——基于采样的默克尔树读写，能够在减少交流成本的同时保证对80%恶意政治家的容忍度。

在委员会中时，公民通过政治家八卦信息而不是直接相互八卦以减少交流成本；一个公民写出的数据在政治家们之间进行传播，然后感兴趣的公民可以从政治家处读取。

由于Blockene中的参与是轻量级的，系统需要针对西比尔攻击进行防护：防止一个敌手产生大量的虚拟节点来获得比例失衡的投票份额。为了阻止这样的攻击，Blockene需要参与者的身份由多数智能手机拥有的可信硬件（TEE）进行认证，并强制确保每个TEE在区块链上最多只能拥有一个活跃的身份，从而将参与的经济成本提高到了一部具体智能手机的成本。

为了限制80%恶意政治家可能对性能造成的损害，Blockene采用了几种技术来约束他们撒谎的能力。首先，我们使用一种叫做“预先声明承诺”的技术，使一些恶意行为变得可检测。其次，为了在80%欺骗率的情况下仍能可靠并高效地实现政治家们之间的交流，我们引入了一种叫做“优先级八卦”的技术。这些技术在公民节点处减少成本，使得Blockene即使在智能手机上运行也能实现高吞吐量。

我们为Blockene搭建了一个原型；公民节点在一个安卓应用中实现，政治家节点以云服务器的形式实现。我们在不同维度上对Blockene进行了评估，并展现出它实现了1045个交易/秒（6.8MB/min）的、良好的交易吞吐量，同时保证了第99个百分点的提交延迟为270s。我们同样还展现了公民节点上极少的数据用量（61MB/天）和电量消耗（3%/天）。

本文的主要贡献如下：

- 我们提出了第一个节点可以作为一等成员参与共识、并在智能手机等轻量级设备上运行的区块链，它可以支持大规模成员与高吞吐量。
- 我们提出了一个新颖的、带有新安全模型的信任分割设计，其中模型由资源受限的公民（多数诚实）和资源丰富的政治家（多数不诚实）组成，公民以可验证方式将繁重的工作卸给不诚实的政治家，通过这种方式完成验证与共识。
- 我们完成了一些新的优化（比如预先声明承诺、基于采样的默克尔树读写、优先级八卦），使得区块链即使在拥有80%恶意政治家的情况下也能达到较好的性能。
- 通过深入完整的理论分析，我们证明了Blockene满足安全性、活跃性和公平性。
- 我们对这一架构进行了全面的经验性评估，展示了它作为一个可扩展的共享区块链服务的可行性。

本文余下部分的结构如下：在$\S 2$中，我们提供了区块链的相关背景知识，并在$\S 3$中讨论现有的区块链架构。$\S 4$提供了Blockene及其威胁模型的概述，$\S 5$介绍了其设计。我们在$\S 6$中讨论了对资源需求大的步骤进行的优化，在$\S 7$中进行有关安全性及活跃性的证明概述，并在$\S 8$中叙述了系统的实现。我们在$\S 9$中对Blockene进行评估，并进行总结（$\S 10$）。



## 2 背景

这一部分中，我们讨论区块链中的核心原则、抽象概念及其应用。

### 2.1 基本属性

区块链是一系列交易的分布式账本。该账本不由可信的权威方（例如银行）进行管理，而是有一组彼此不信任的多方集体验证交易并维持一致的账本，前提是至少有一定比例的参与者（例如三分之二）是诚实的。区块链必须提供安全性、活跃性与公平性。安全性保证诚实的参与者看到的账本是一致的。活跃性保证恶意参与者不能通过阻止新区块的添加来无限期地拖延区块链。公平性确保所有上交给区块链的有效交易最终都会被公开提交。

### 2.2 建造区块

区块链是一个经过复制的点对点分布式系统，建立在以下基本原语之上：

**全局状态的默克尔树：**区块链的一个关键部分是全局状态的数据库，它对键及其当前值进行跟踪。该全局状态是以防篡改的方式进行管理的，通常使用一个默克尔树，其中叶节点存储键值对，而每个中间节点包含其子节点连接内容的一个散列值。根节点是一个单独的散列值，表示整体状态。一个键的更新仅需要在其对应叶节点到根节点的路径上对散列值进行重新计算。给定根节点时，任意一个键的值都可以由一条到达根节点的有效散列值路径来验证。

**签名的交易：**区块链中以交易为基本工作单位。一个交易读取并更新全局状态中的几个键（例如，Alice转账1000美元给Bob）。交易有效需要满足（1）交易必须进行签署（2）签署交易的用户必须有访问相关键的权限（3）必须满足语义完整性（比如不能超支）。

**加密连接：**区块链是多个区块的列表。一个区块是多个交易的列表。区块的排列顺序由一个加密连接来保证；每个区块中会嵌入前一个区块内容的加密散列值。

**八卦：**区块链中的参与者以点对点的形式相互交换状态信息。比如，当一个新的区块被提交到账本上时，它必须被发送给其他成员。这种交流通过多跳的八卦来实现，最终可达到一致性。

**共识协议：**区块链中的核心原语是一个可以处理拜占庭故障（如PBFT、Nakamoto或BBA）的分布式共识协议，因为少部分参与者可能是恶意的。拜占庭共识要求至少三分之二的参与者是诚实的，并且需要进行多轮交流。



## 3 与现有区块链的比较

本节中，我们将简要介绍现有区块链架构的相关工作。Blockene具有三个属性：轻量级资源使用、大规模的参与以及高交易吞吐量。我们使用相同的三个维度来对比Blockene与相关工作。

### 3.1 成员节点的资源使用情况

现有区块链中，参与成员节点的资源使用情况跨越了广泛的范围，具体取决于采用的共识机制。我们首先讨论成员节点承担的计算开销，然后讨论网络与存储开销。

**计算开销。**对于计算开销，消耗最多的是基于中本聪共识的区块链，该共识也被称为工作量证明；实例有比特币及以太坊。在中本聪共识中，第一个解决了一个计算密集型加密难题的成员节点被选择为提交新区块的赢家。因此，这样的区块链在成员节点处需要大量的计算资源。

为了解决工作量证明区块链的高计算（及能源）开销问题，两种流行的替代架构出现了。第一种是联盟链（比如超级账本HyperLedger），通过将区块链成员限制在少量节点上，它可以运行传统的拜占庭共识算法，而不是基于工作量证明的计算密集型共识。第二种架构是权益证明区块链，它将一个成员节点的投票权利与其在区块链上的钱数进行绑定。这种区块链的例子有Algorand、Ouroboros、PeerCoin等。从本质上讲，权益证明区块链针对的是这种“权益”有实际意义的加密数字货币应用。

**网络和存储开销。**虽然上述两种架构，即联盟链与权益证明区块链，解决了成员节点的原始计算开销问题，它们对于智能手机来说仍然是代价高昂的。特别地，它们需要大量的网络与存储资源，因为它们要求成员节点始终与区块链的“当前”状态保持一致。考虑到这种区块链允许的交易高速率（每秒千余次交易），在成员节点直接复制整个状态是代价昂贵的：在1000交易/秒的速率下，区块链每天需要提交约9GB数据，这些数据需要在成员节点之间进行传播，导致每天每个成员节点需要承担的网络开销约为45GB（假设一个八卦传播至五个邻居）。进一步地，由于每个成员节点都要存储区块链的一个副本，这样的区块链会在成员节点处消耗TB级的存储空间。

即使是针对智能手机的区块链也采用了让成员节点保持最新状态的相同理念，从而产生网络与存储的开销。

一些区块链通过分区解决存储开销问题。OmniLedger是最近的一个区块链，它只允许参与者存储区块链的一个碎片，使用ByzCoin的一个变体实现快速共识。RapidChain同样使用分区来减少存储成本。这两项工作都只能容纳几千名参与者的规模，并且也需要参与者存储完整区块链的很大一部分（$\frac{1}{3}$或$\frac{1}{16}$）。

**轻量但无用的节点。**一类区块链采用了“不平等成员”的形式：只有资源丰富的第一级成员参与共识并拥有投票权，而第二级成员仅作为只读的查询前端，不参与共识。在这种模型中，“多数诚实”的属性必须完全由重节点满足，因为轻节点对安全性没有贡献。不足为奇的是，考虑到其有限的职责，这些“轻”节点不会消耗多少资源。这种架构的一个实例是以太坊中轻重节点间的分离。

**Blockene。**相反地，Blockene为参与共识和区块验证的一级成员提供了轻量级的资源使用。进一步地，不同于以太坊依赖于重节点间的诚实多数（只有重节点可以投票），Blockene可以容忍“重”节点（即政治家）高达80%的腐败率。Blockene中的成员仅需要一部智能手机以及可忽略不计的数据传输（<60MB/天，即减小了三个数量级）。它实现该结果是通过让成员节点利用提交特定区块所需的最小状态进行操作，并且一天内仅执行几次工作，也就是说，不需要时刻努力跟进最新状态。

### 3.2 参与规模

区块链的安全性在本质上依赖于参与成员中的大多数是诚实的，所以需要防止大量参与者的合谋。联盟链为特定的业务流程精心地构建了区块链，使得成员们在区块链的成功下有共同的奖励机制。有时候组织一个具有上述担保的联盟链是不可行或者困难的；在慈善事业的例子中，如果一小部分成员控制着区块链，他们可能会串通一气，将本应用于穷人的捐款抽走。除此之外，联盟链是与一组实体之间的特定业务流程紧密联系在一起的，不仅会限制互操作性，也会导致高昂的设置及运营开销。

防止多数人进行合谋的另一种方法，是允许大规模的参与；通过招募大量的参与者（比如数百万人），多数合谋就会变得困难、不可能。大多数“公共”区块链如比特币、以太坊、Algorand都允许大规模的参与。Blockene同样支持大量的参与者，但是不同于当今大部分针对加密数字货币的公共区块链，Blockene不是与加密货币绑定的（例如不采用权益证明），而是允许一般的业务交易。不同于联盟链的是，Blockene还能够在少数成员可能进行合谋的实际场景中提供额外的支持。

### 3.3 交易吞吐量

基于工作量证明的公共区块链吞吐量较低（大约4~10次交易/秒）。基于权益证明的Algorand是第一个达到约1000次交易/秒的公共区块链。联盟链，由于其小规模参与及传统共识（如PBFT），支持每秒超过1000次的交易。与Algorand相似，Blockene同样提供高交易吞吐量。由于不与加密货币应用绑定，Blockene可以为类似联盟链的传统商业应用提供服务。

| 区块链           | 成员规模 | 交易速率   | 开销               | 是否需要激励 |
| ---------------- | -------- | ---------- | ------------------ | ------------ |
| 公共（如比特币） | 数百万   | 4-10/      | 巨大（工作量证明） | 是           |
| 联盟链           | 数十     | 1000+/     | 大                 | 是           |
| Algorand         | 数百万   | 1000-2000/ | 大                 | 是           |
| Blockene         | 数百万   | 1045/      | 小                 | 否           |

表1：区块链架构的比较

### 3.4 参与者的激励

由于高额的资源开销（计算、网络或存储），现有的区块链需要为参与者提供奖励机制（比如在加密货币中挖掘货币，或联盟链中提高业务效率）。依赖于这种奖励机制的区块链不能为类似慈善事业的应用工作（$\S1$）。要在没有激励的情况下扩大规模并允许利他主义的活动，参与的成本必须是可以忽略不计的。

表1在这些维度上对比了各区块链架构。Blockene是第一个达到以上所有目标的区块链：规模、吞吐量和低开销。Blockene以其低成本支持实际的使用案例，即使参与者没有直接的奖励动机，而是在利他地以威不足道的电池和数据使用量运行一个后台程序。

### 3.5 其他相关工作

Blockene中基于委员会的共识在很大程度上受到了Algorand的启发；和Blockene相似，Algorand同样不允许产生分支，区块链始终保持一个一致的状态。Algorand和Blockene在两种针对性攻击（在$\S4.2$第一段中描述）的恢复力上进行了权衡。HoneyBadger是一个最近为$O（100）$参与者的联盟链设计的系统。IOTA是另一个分布式账本系统，但是目前依赖于一个中心协调机构来达到共识。

在基于工作量证明的区块链中，与Blockene联系最紧密的工作是混合共识。和Algorand（及Blockene）类似，混合共识周期性地选出一组参与者，并且在“参与者选择间隔”中不允许敌手破坏节点。但是，它具有一个时间较长的选择间隔（大约一天），并且也对分支开放可能性。



## 4 架构概述

在本节中，我们首先介绍我们的两层体系结构，它实现了轻量资源使用、大规模参与和高事务吞吐量这三个相互冲突的属性。然后我们讨论Blockene的威胁模型。

### 4.1 两层体系结构

Blockene采用了一个新颖的两层体系结构，拥有不对称的信誉。这一架构在图1中得到展示。

Blockene中有两种节点：公民和政治家。公民节点资源受限（即在智能手机上运行）、数量庞大（数百万）并且是系统中唯一拥有投票权利（即参与共识）的实体。政治家能力强大、在服务器上运行（与现有的Algorand类似），数量要小得多（几百），但是它们没有投票权。政治家只是执行公民们做出的决定，不能自己做任何决定。

较低的资源使用使得大量的公民可以在没有激励的情况下参与，而数量较少的政治家可以由对特定使用案例感兴趣的大型实体来运行（如审计慈善的例子中的大额捐款方及组织）。

公民在参与共识时，要求至少三分之二的公民是诚实的，而其他人可以是恶意的并进行合谋。这一要求是合理的，因为Blockene允许数百万的公民参与，这使得大规模的腐败很难发生。然而，政治家得到的信任则要少得多。Blockene只要求20%的政治家是诚实的；其余80%的政治家可以是恶意的，并可以互相串通、与三分之一的恶意公民串通。

#### 4.1.1 政治家分担工作

直观上来说，考虑到两层体系结构，公民们可以将存储、交流等代价昂贵的责任卸给政治家。但是当80%的政治家都是腐败的时，公民的一次写操作可能会被政治家丢弃，或者一次读操作可能会返回错误的值。为了让政治家完成有效用的工作，Blockene蚕蛹了一种新颖的复制读写机制。公民对政治家进行的读写操作随着一个随机、安全的政治家样本进行。该样本的大小固定，且满足样本中至少有一个诚实政治家的概率很高（例如，对于大小为25的样本来说，其概率为$1-（0.8）^{25}=99.6\%$）。Blockene对于少数挑选了所有不诚实政治家的公民（0.4%）具有恢复弹性。

#### 4.1.2 职责分配

现在我们描述公民和政治家如何通过合作来执行各种区块链上的标准任务：

**存储：**在传统区块链中，每个参与者都维护一份完整区块链的副本，但是Blockene中的公民节点负担不起TB级的数据存储。在Blockene中，只有政治家存储账本和全局状态（即$\S2$中的键值数据库）。公民根据需要，从政治家处读取这些数据的子集。公民唯一需要存储（并周期性更新）的状态是有效公民身份的列表（$\S5.3$）。

**交易验证：**因为公民是共识中的实际参与者，所以他们对交易进行验证，确保交易得到签署并具有语义完整性（如没有二次支付）。为了执行验证，公民从政治家处读取交易，然后从政治家的全局状态中查找交易中引用键的最新值。

**八卦：**为了确保所有诚实参与者对区块链的状态意见一致，参与者之间需要互相八卦。然而，正如$\S3$中所讨论的，公民之间直接的八卦是昂贵的。Blockene让公民通过政治家来进行八卦，从而解决了这个问题。当一个公民需要向其他公民广播信息时，它向一个政治家的安全样本发送消息。随后政治家之间传播数据；它们能够负担得起这样做，因为它们拥有良好的网络连接。然后其他公民可以在它们需要时对政治家执行一次复制读操作，比如当它们在委员会中时。对于政治家之间的八卦，我们需要保证到达了一个诚实政治家的消息总是能通过八卦到达其他所有的诚实政治家，当有80%的恶意政治家时这是一个具有挑战性的目标；我们自定义的八卦协议在$\S6.1$中得到了描述。因此，我们实现了和公民间直接八卦相同的语义，但公民处的网络负载达到了最低限度。

**共识：**公民通过政治家进行八卦，以此参与共识。考虑到公民的庞大规模，所有公民不能都参与共识。相反，我们用加密方式为每个区块随机选出一个公民委员会（大约2000名成员）（见$\S5.2$）。

### 4.2 威胁模型

虽然我们的模型与Algorand相似，但是对于针对性攻击的恢复，Algorand和Blockene各有权衡。一方面，Algorand是基于权益证明的，这使得敌手拥有无限的时间来针对权益较高的节点（它们会更频繁地出现在委员会中）；Blockene避免了这种攻击，因为所有公民拥有相同的票数。另一方面，Algorand在委员会成员履行自己职责之前保护它们的秘密，而Blockene在它们参与的几分钟前（1-2个区块前）就会暴露它们的身份。为了节省电量，公民通常每隔约10个区块（$\S5.2$）就为区块链当前状态的政治家进行一次投票，但是当它们即将进入委员会时，会在预期轮到它们之前不久（如一个区块前）再次投票，从而向恶意的政治家暴露自己的身份。这为针对性攻击提供了一个潜在的窗口（例如通过贿赂委员会：$\S4.2.1$）。

#### 4.2.1 公民的攻击途径

**对公民的贿赂攻击：**由于Blockene会提前几分钟隐式暴露委员会的公开密钥，理论上敌手可以通过贿赂足够数量的委员会成员来实施针对性攻击。然而，出于以下原因，我们认为这不构成一个问题。首先，仅凭IP地址，对手向公民“发送信息”来行贿并不是什么小事，这是由于运营商级NAT，以及智能手机推送通知的架构；一个从恶意政治家到公民的现有频道不可能为此被滥用，因为在公民处未被干扰的Blockene应用会忽略该频道上的任何虚假流量。第二，由于委员会是在每个区块产生时随机选择的，基于拉动的贿赂，即公民（提前10个区块知道自己的选择）主动接触敌手的贿赂，是不可能发生的，因为这意味着违背公民的诚信假设，也即，超过70%的公民是诚实的。

**公民的西比尔攻击：**考虑到参与的成本很低，Blockene需要确保对手不能通过自己运行几个虚拟节点（即西比尔攻击）来获取不成比例的投票份额。解决西比尔攻击的一种常见方法是工作量证明，这是资源密集型的，不符合Blockene的目标；另一种选择是权益证明，其中参与者的投票权与区块链上的“权益”（金钱）数量成正比，但它只用于加密货币。

在Blockene中，我们通过利用智能手机中可以找到的可信硬件（TEE）来阻挡西比尔攻击，并确保一部智能手机在区块链上最多只能拥有一个身份。因此，Blockene为参与带来了经济成本，即一部智能手机的成本；这是拥有智能手机已经带来的沉没成本，但同时也能防止西比尔攻击，因为每个身份都对应一个特定的智能手机。

特别地，每个TEE都有一个由平台（Android/iOS）供应商认证的唯一公钥。TEE可以认证由应用程序生成的EdDSA公私密钥对；这个生成的公钥作为Blockene上的标识。Blockene的全局状态对有效公钥集，以及为它授权的TEE的公钥/证书进行追踪。当一个用于添加新成员的交易被提出时，Blockene会查找TEE的公钥，以查看这个TEE（即对应的那部智能手机）是否已经在Blockene中有了一个身份；如果是，则拒绝该交易。因此，Blockene上的每个公民都与一部特定智能手机绑定，这使得单个实体在Blockene上进行大规模参与的行为在经济上是不可行或者没有吸引力的。

需要注意，Blockene只假设了每一个由谷歌/苹果发放签名证书的TEE公钥对应一部特定的智能手机。它不依赖于单个TEE的安全性（不同于在TEE内部运行区块链共识，例如SGX，这会导致侧通道攻击，损害完整性和安全性）。因此，TEE标识可以被其他唯一标识替换，或与之结合。在印度可以使用单向哈希的Aadhaar-ID（可数字验证、生物识别去重、12亿规模）。其它带有数字验证功能的数据去重ID（如SSN）也可以被采用。

#### 4.2.2 政治家的攻击途径

Blockene设计中的主要技术挑战之一，是处理政治家中80%的不诚实。政治家的恶意行为分为两种：可察觉的和隐蔽的。可察觉的恶意中有简单证据证明政治家撒谎，可以通过将其列入黑名单来提高性能。比如，如果一个政治家在一轮中本应只发送一组交易，但实际上存在由同一位政治家签名的两个版本，这就是有证据、可察觉的。隐蔽的恶意行为更难处理，也是我们技术的重点。我们列出了政治家可采用的隐蔽攻击的大致（非详尽）类别。

**过时攻击：**当公民节点向政治家请求某些状态（例如，最新提交的块）时，政治家可以返回一个过时的块。这样的响应看起来是有效的，因为旧区块也是由合法人数的公民签署的（$\S5.3$）。

**观点分裂攻击：**政治家可以选择性地对某些公民做出响应，而不回应其他公民，造成诚实公民们世界观的分裂。更糟糕地，政治家可以用两种不同的值来回应不同的公民子集。在一次协调好的观点分裂攻击中，恶意政治家们只在彼此之间进行八卦，使得任何诚实的政治家都没有确定的数据。然后，恶意的政治家就可以选择性地将这些数据转发给某些公民（如$\S5.5.2$）。

**丢弃攻击：**一个恶意政治家可能会丢弃公民写入的数据，而不会将其提交或是传播给其他政治家。同样，在数据读取时，政治家可能会选择不回应，即使它有数据（$\S4.4.1$）。

**拒绝服务攻击：**由于政治家是通常托管在云中的强大服务器，我们假设诚实的政治家采用公共云提供的标准DoS保护。对于公民来说，大多数ISP使用运营商级NAT来处理移动电话上IP地址的爆炸式增长，它也提供DoS保护。恶意政治家可以通过请求比他们需要的更多的数据，使得我们的八卦协议更加昂贵（$\S6.1$）。

**西比尔攻击：**敌手可以通过自行启动一些节点将政治家的不诚实率推到80%以上。然而，考虑到政治家数量很少（比如说200个），我们设想政治家节点应该有一个带外的注册机制（例如将他们映射到真实实体，可以是每个对应一个财富500强公司）——比较稳健，因为只有20%的节点需要是诚实的（不像公民）。

Blockene可以同时抵御政治家们可探测和隐蔽的恶意攻击，包括上面列出的攻击。



## 5 设计

在本节中，我们将更详细地介绍公民和政治家如何在Blockene的关键步骤上进行协调。

### 5.1 系统配置

我们首先简单概括Blockene的系统配置。Blockene中的公民在智能手机上运行，所以我们假设他们的网络带宽很低，即1MB/s。我们选择9MB的区块大小（以摊销每个块的固定成本），其中包含大约9万项事务（每项事务大约100个字节，包括一个64字节的签名）。我们假设政治家之间的网络带宽为40MB/s（代表云中的带宽，例如横跨美国东西部的Azure和谷歌云VM之间的带宽）。我们选择政治家的数量为200。每个区块所做的工作只取决于委员会的规模，因此该系统的规模由百万级的公民来衡量。

在后台，交易发起者持续地将签署的交易提交给一个安全样本或所有政治家。事务可以修改发起者有权访问的密钥。来自同一发起人的交易可以彼此依赖；我们通过追踪全局状态中的每个发起者拥有的nonce来保存它们的顺序。在本文中，（不失一般性地）每个交易访问三个键（一个对应借，一个对应贷，第三个键是nonce）。政治家之间进行有关交易的八卦。

### 5.2 选举公民委员会

对每个区块进行验证和签名的公民委员会是根据VRF（可验证随机函数）选出的，它受到了Algorand的启发，但有一处关键的修改。Algorand要求每个参与者在每一轮中都检查自己是否被委员会选中。一个在手机上运行的公民无法承担如此频繁的检查，因为每轮都唤醒手机并进行通信会导致大量的电池消耗。因此，Blockene不是根据前一个区块哈希值（N-1）计算VRF，而是使用区块N-10的哈希值，从而允许公民每10个区块苏醒一次。注意，这一修改仍然保留了我们威胁模型中VRF函数所需要的安全保证。具体来说，对于一个公民，区块N的VRF计算公式为$Hash（Sign_{sk}（Hash（Block_{N−10}）||N））$，其中$sk$是公民已知的私钥。如果VRF在最后的k位中包含0，那么该公民就进入委员会中（因此一个公民在委员会中的概率为$2^{-k}$；k可以进行适当的设置）。只有有关公民才能生成VRF，因为计算需要它的私钥，而任何人都可以根据给定签名的公钥来验证它的有效性。

**委员会规模：**委员会的规模需对性能和安全性进行平衡。一个小规模委员会有较好性能，但为了共识协议的安全性，我们要求在任何委员会中，至少2/3的公民是诚实的。由于我们的委员会选择是概率性的，根据切尔诺夫界，即使我们总体上有2/3的诚实公民，对于非常小的委员会来说这个安全要求也无法满足。委员会的规模随着不诚实公民的比例而增加。我们对这一权衡进行校准并得到委员会的预期规模为2000人，公民的不诚实阈值为25%。这些计算细节在完整版中。我们在下面给出概述。

**证明概述：**我们证明几个关于区块委员会的属性。我们称一个参与委员会的公民是好的，如果这个公民是诚实的，并且通过m-扇出读写与至少一个诚实的政治家交流。否则，我们称该公民是坏的。对于25%腐败公民、80%腐败政治家，且m = 25的配置，我们证明了我们的委员会满足下列性质：所有委员会的规模在$[1700..2300]$范围中（引理1），每个委员会至少有1137个好公民（引理2），每个委员会至少有2/3的好公民（引理3），没有一个委员会有超过772个坏公民（引理4）。

### 5.3 防分支结构验证

Blockene的设计会防止分支产生。为了实现这一点，每个公民定期验证区块链的结构完整性，以强制保证哈希与VRF的链是一致的，并防止分支。

**跟踪本地状态：**每个公民在本地记忆区块号N，直到该公民验证了区块链的结构完整性，以及区块N到N−9的哈希值。此外，公民存储了其他有效公民的公钥的最新列表。对于100万居民，总存储大小小于100MB。

**链接ID子块：**为了使市民能够高效地更新本地状态，作为每个块B的一部分被添加的新用户公钥，在B中的一个ID子块（SB）中被追踪。通过将$Hash(SB_{i-1})$嵌入$SB_i$，子块被链接在一起。委员会成员签署$Hash(Hash(B_i), Hash(SB_i), GlobalStateRoot(B_i))$，以助于低成本的验证。

**增量验证：**大约每隔10个区块（12-15分钟），每个公民执行一个getLedger调用来验证增量的结构完整性（即，从最后一个验证点到最新状态），并检查它是否即将进入委员会（区块N的委员会是区块N−10散列值的一个函数）。要找到最新的区块，公民可以向一个政治家的安全样本查询最新的区块号。它挑选出所有政治家报告的数字中最大的，并请求提供验证，即该区块委员会的签名和相应的VRFs。因此，如果安全样本中至少有一个政治家是诚实的，那么公民就能知道最新区块的哈希值。如果最新的区块大于N+10，它首先验证区块N +10。此外，它通过下载链接子块$SB_{N+1}…SB_{N+10}$来刷新其有效公钥集，其中链接子块包含添加到每个区块的新公民，通过哈希链验证$SB_i$的完整性。

**新节点降温期：**在一种（低概率）攻击中，敌手可以制造公有-私有密钥对，以增加在特定区块N中获取更大恶意部分的机会。为了防止这种攻击，从一个公民被添加的区块算起，我们只允许该公民k（=40）个区块之后才能加入委员会。为了验证这一点，作为VRF检查的一部分，一个公民的本地状态追踪“最近”添加公民的区块号。这与Algorand中的“回顾参数”类似。

**证明概述：**我们的getLedger协议用于在给定公民v上一次的验证高度$i$时，验证账本高度$i+10$，而不需要对所有10个区块的签名进行显式的蛮力验证。该算法可推广到验证$1≤j≤10$的任意高度$i+j$。我们证明了（引理5）如果一个验证了高度$i$的好公民，在第$i+11$轮调用getLedger协议并接受，那么该公民更新后的结构状态在高度$i+10$之前与区块链一致。由此，我们可以证明诚实的公民可以在协议的每一轮中都获得一致的区块链结构状态，以及所有注册公钥(推论2)。

### **5.4** 交易验证

公民执行验证交易签名、检查交易nonce以检测重放攻击、验证交易语义正确性（如重复消费）的任务。然而，只有政治家才存储全局状态的默克尔树（$\S2.2$）;在公民中维护一个庞大的、最新的全局状态是负担不起的。要验证一项事务，公民必须查找其中引用的键的正确值。提交时，公民必须用事务提供的新值更新默克尔树，并签署新的默克尔根节点。挑战在于如何在考虑到不受信任的政治家时正确地做到这一点。

默克尔根（连同区块号）是由前一个区块的委员会签署的，因此政治家不能编造关于默克尔根的谎言。一旦市民知道了最新的区块号（$\S5.3$），它也就知道了正确的默克尔根。为了验证一个根据键返回的值，公民要求政治家发送该键的挑战路径，即，从叶节点到根节点的路径上的所有兄弟节点（散列）。这使得公民能够重构默克尔路径，并将根散列与签名的默克尔根匹配。由于哈希的安全性，政治家无法给出虚假的挑战路径来通过验证。在具有10亿个键值对的树中，挑战路径包含30个散列。

默克尔树中的密钥更新遵循类似的协议。市民可以用叶节点处的新值构建部分默克尔树，并计算新的默克尔根。上面提到的读取和更新路径都是代价高昂的，我们在$\S6$中对它们进行了优化。

### 5.5 区块提案

与任何区块链一样，委员会成员可以提出一个要提交到区块链上的新区块。

#### 5.5.1 选择胜出提案者
为了提高效率，我们只允许区块委员会中的一个子集根据公民的VRF真正提出一个区块，它们被称为提案者。对于这个选择，我们使用一个附加的VRF，它基于前一个块N−1（而不是N−10）的散列；只有附加VRF的最后$k'$位为0的委员会成员才可以提出区块，而获胜者是拥有最小VRF的那个。在这个VRF中使用上一个区块的散列可以确保敌手直到最后一刻才知道提案者（与Algorand类似），从而防止提案者遭受针对性攻击。任何委员会成员都可以在提案者中确定胜出的VRF。所有提案者将他们的区块上传给政治家，然后其他委员会成员下载胜出提案者的区块。

#### 5.5.2 预先声明提交

提案者需要将提议的区块上传到25名政治家的安全样本中。Blockene中的区块大小约为9MB，假设移动节点处带宽为1MB/s，这将需要225秒。为了对这一步进行优化，我们使交易选择的过程是确定性的，这样任何公民都可以重现原提案者会做的事情，而不需要提案者显式上传完整的区块。然而实现确定性是具有挑战的，因为80%的恶意政治家可以向不同的公民发送不同的交易。我们对交易进行预先声明提交的技术解决了这个问题。

1. **冻结交易**。在区块N的开始，每个政治家对它将要发送给待读取公民的确切交易集进行冻结。它通过创建一个tx_pool来实现这一点，该tx_pool包含一组（大约2000项）事务，然后生成一个提交记录，它是tx_pool的签名散列和区块号。对于一个给定的区块N，恶意政治家被迫只能发布一个提交记录，因为同一政治家签署两个承诺就是恶意行为的证明，可以用于有效的黑名单机制；然后在同一轮中，公民就会丢弃该政治家的所有提交。直观上来说，在冻结提交的情况下，公民提议一个区块时不需要上传整个区块，而只需上传一个包含该区块提交记录的摘要，然后其他公民可以通过从政治家那里下载这些提交对应的tx_pools来重建该区块。

2. **确保足够多的诚实公民拥有提交。**一个恶意的政治家可以只用它的tx_pool回应一部分公民，并拒绝回应其他人；因此，在提议的区块中提交的tx_pool可能不能被所有诚实市民读取，从而阻碍共识的达成。为了解决这个问题，我们执行三个步骤。首先，我们限定一个政治家的确切集为，根据区块号和前一个区块哈希值随机选出的45名政治家集合，从这些政治家处为给定区块拉取交易。公民从这45个指定政治家处为一个区块读取tx_pools，而不是从一个随机的安全样本中进行读取。第二，公民将一份证人列表上传给一个政治家的安全样本；证人列表包含公民能够成功下载的tx_pool列表。所有公民的证人列表会在政治家们们被八卦传播。第三，提案者读取所有其他公民的证人列表，并只挑选那些tx_pool被至少阈值数量的公民成功下载的提交。这个阈值被固定为$\widetilde{n_b}+\Delta$，其中$\widetilde{n_b}$为任意委员会中恶意节点的最大数量（由引理4计算得出为772），$\Delta$选择为350。直观上，满足这个条件的所有提交（和tx_pools）对于至少$\Delta$诚实公民是可用的。由于20%的政治家是诚实的，预计45项提交中至少有9项会通过这一测试。
3. **确保所有诚实公民可获取提交。**至少有$\Delta$诚实公民可用的提交现在需要向传播至所有诚实公民。在步骤4中的每个公民重新上传5个随机的tx_pool给1个随机的政治家。这确保了（有很高的概率）每个属于至少$\Delta$诚实公民的tx_pool（包括那些来自恶意政治家的）会到达至少一个诚实政治家（然后它会把它八卦给其他诚实的政治家）。因此，其他诚实的公民可以成功地下载tx_pool（通过询问一个政治家的安全样本），以防止恶意政治家的观点分裂攻击。
4. **处理恶意的提案者。**当区块提案的获胜者是恶意公民时，它不需要遵守证人列表的规定，并且可以选择一个tx_pool为极少数公民所知的提交。只有当共识将这个恶意提案者提出的区块作为输出时，这种攻击才可能发生，所以我们可以认为至少有1/3的诚实公民在共识开始时拥有所有的tx_pool。为了确保所有诚实的公民都能够下载所有需要的tx_pools，每个公民将再次上传随机选择的tx_pools（第9步），这一次包括从上一步中下载的tx_pools。引理10和11给出了这些重新上传所提供的保证的形式证明，这些保证可用来证明系统的安全性。

### 5.6 块提交协议

区块链的主要操作是向区块链添加一个新块。我们在下面列出了提交区块N的关键步骤。区块N的协议开始于前一个区块N−1从它的委员会成员处收集到阈值签名数(在我们的例子中设置为850)时。

1. 为区块N选择一个新的公民委员会(使用区块N−10的哈希值)，表示为$C^N$。$C^N$中的公民对最新提交区块的编号进行轮询，当提交块号为N−1时启动协议。
2. $C^N$中的每个公民$C^N_i$从$\rho=45$名指定政治家处，为当前区块下载tx_pools和提交记录。
3. 每个$C^N_i$将一个签名的、带有它下载的提交记录证人列表上传给一个政治家的安全样本。
4. 每个公民$C^N_i$选择5个随机的tx_pool，并将它们重新上传给1个随机的政治家。
5. $C^N$中的每个提案者都从一个安全的政治家样本中下载$C^N$的所有证人列表，并选择至少有1122票的提交($\S5.5.2$)。然后，它用这些提交记录生成一个区块提案，同时包括其VRF，以证明提案者资格。
6. 政治家对区块提案/VRFs和公民重新上传的tx_pools进行八卦。
7. 依赖其他公民的重新上传（步骤4），每个公民$C^N_i$从一个政治家的安全样本处尝试下载步骤2中缺失的tx_pools。
8. 每个公民$C^N_i$从一个政治家的安全样本处读取$C^N$中所有提案者的VRFs，并选取最小的正确VRF作为本地胜出者。如果$C^N_i$拥有胜出提案中的所有tx_pools，它将携带该提交集加入共识，否则携带空集。
9. 每个$C^N_i$进行第二次重新上传，将10个随机的tx_pools上传给1个随机政治家。
10. $C^N$中的公民通过政治家之间的八卦运行一个共识机制（$\S5.6.1$），其中每个$C^N_i$的投票在步骤8中确定。最终，所有诚实公民会对同一个提交集或者一个空区块达成一致。根据来自政治家安全样本的共识输出，$C^N_i$下载缺失的tx_pools。
11. 每个公民$C^N_i$通过从政客那里下载所有密钥的挑战路径来执行交易验证（$\S5.4$），并丢弃验证失败的交易。
12. 根据通过验证的事务(步骤11)，每个$C^N_i$创建一个区块，使用更新的键值计算全局状态的新Merkle根，并对块散列、新Merkle根以及块号N进行签名。它将块散列、新Merkle根和这个签名上传给安全的政治家样本。
13. 当区块N收集的签名数超过阈值时，区块N+1开始。

我们的完整协议描述可以在算法4中找到。在$\S7$中，我们对Blockene的各种性质作了概述，即安全性、活跃性和公平性。

#### 5.6.1 共识协议

对于共识(第10步)，我们使用拜占庭协议(BA)算法来实现字符串共识，它以黑盒的方式调用比特共识算法BBA。这和Algorand使用的共识算法相同。公民带着本地胜出区块中的提交列表进入共识，作为输入。这里有两种相关场景。如果胜出提案者（即VRF最小的那个）是诚实的（至少在三分之二的情况下会如此），所有委员会中的诚实公民都会带着这一提案进入共识，只有小概率的例外（引理10），并且协议会在5轮之后终止。然而，如果胜出提案者是恶意的，它可以与恶意的政治家合谋，分裂诚实公民们的观点。一般来说，共识协议预计会进行11轮。



## 6 优化

在本节中，我们将介绍在Blockene中实现高事务吞吐量的两个关键优化。

### 6.1 优先八卦

**问题。**我们在Blockene中需要的保证是，如果一个诚实的政治家有一条信息，所有诚实的政治家都会收到这个信息。由于政治家的不诚实率很高，与少数邻居（如10）之间的标准多跳八卦无法提供这一保证，因为他们都不诚实并丢弃消息的概率不算小。因此，安全的做法是向所有其他政治家进行全面传播，但其代价昂贵；当政治家们需要八卦委员会公民重新上传的tx_pools时，每个政治家最多可能有45个tx_pools需要八卦；在完全广播的情况下，它将发送$0.2MB∗45∗200=1.8GB$，这将在关键路径上花费45秒（@40MB/s）。

**关键想法。**我们利用了这样一个事实：不同政治家八卦的信息有很多的重叠；当公民随机选择一个政治家重新上传tx_pools的子集时，每个政治家都有相同45个tx_pools的一个子集。此外，考虑到重新上传的性质，在预期中，任何政治家都只缺少几个tx_pool，而诚实的政治家不会对状态撒谎。

1. **握手。**每个政治家向接收者$B_i$询问它们已经有哪些tx_pool，并且只发送缺失的tx_pool。虽然这对诚实的政治家有效，但80%的恶意政治家可能总是撒谎说它们什么都没有，从而导致系统更高的负载或延迟。

2. **自私八卦。**由于恶意的政治家会撒谎说他们没有tx_pool，我们对遗漏大量tx_pool的政治家进行软惩罚。每个发送者政治家A都偏爱拥有最大A缺失的tx_pool数量的同伴B。在每一轮中，A向B发送一个tx_pool，然后也收到一个tx_pool作为回报。考虑到公民的随机重传，每个诚实的政治家只会缺少一小部分tx_pool，因此会得到更高优先级。当B从其他节点获取tx_pools时，B所能提供的内容列表会不断更新；注意，这个列表只会增长，不会缩小。

3. **鼓励节俭的节点。**一旦发送者接收到所有的tx_pool，自私八卦就失去了区分诚实和恶意接收者的能力。为了解决这个问题，在获得所有tx_pools之后，发送端将计算目的地$B_i$的优先级函数更改为$B_i$声称拥有的tx_pools的数量；这样，具有大量tx_pool的诚实节点更受青睐。同样，B宣传的tx_pool列表只增长而不会收缩，因为收缩意味着B说谎了。此外，每个诚实的$B_i$最多同时向k=5个同伴请求缺失的部分；k=1时是数据节俭的，但如果同伴不诚实地推迟响应，将导致高延迟。

### 6.2 基于采样的默克尔树读写

**问题。**第11步中的默克尔树验证代价很高。在一棵10亿节点的默克尔树（30层深度）中，一个挑战路径是300字节（10字节哈希）；忽略压缩，下载270K挑战路径是81MB（$\widetilde{8}1$秒延迟）。公民处的计算量也很高（在读取进行挑战路径的验证，以及在更新后计算新根，总共进行了1620万次哈希计算）。

**关键想法。**我们以一种可验证的方式，把大部分工作交给了政治家们。因为默克尔树验证是在共识运行结束后通过对政治家的八卦进行的，所以政治家知道构建区块所用的tx_pools。因此，委员会的所有公民和政治家都知道哪些键的值需要进行读取和更新。我们首先讨论从默克尔树正确读取值的优化。

1. **获取值。**每个公民只从一个政治家那里获得所有270K个键的值（没有挑战路径，是1MB而不是81MB），然后询问一个安全的政治家样本这些值是否正确。因为这些政治家中至少有一个是诚实的，所以它通过一个异常列表提醒市民有不正确的值。通过提供一个由已签名的默克尔根开始、并指示了这个键对应了不同值的挑战路径，政治家可以“证明”一个值是不正确的。

2. **抽查。**如果许多值都是错误的，那么异常列表将会非常大，并消耗存储。为了避免这种情况，Citizen取包含k'=4500个键的一个小随机子集，用于初始时使用挑战路径进行抽样检查。如果抽样检查对一个足够大的k'通过，一个政治家只能针对一小部分（200）键撒谎（只有很小的概率会发生例外）。因此，额外的抽查限制了异常列表的大小（引理6）。

3. **异常列表协议。**为了与政治家的安全样本交叉验证这些值，公民确定性地将这些值放入桶中（2000），并上传这些桶的哈希值。当政治家注意到一个桶不能匹配时，它将发送桶索引和该桶中所有键的正确值。公民只有在键值（与第一个政治家）不一致的情况下才获取挑战路径。我们的抽查确保只有少数桶会不匹配。

**边界情况。**即使在做了上面的事情之后，仍然有很小的概率（$<2^{-10}$）公民会获得不正确的值；我们将这样的公民节点视为恶意的，并对其进行适当的处理（引理7）。算法2给出了完整协议和所有的证明。

**写：**更新默克尔树是一个更棘手的问题。由于缺少所有待更新密钥的旧挑战路径，公民不能构造更新后的默克尔树T‘的根。我们通过让政治家计算T'来解决这个问题，但是现在公民必须验证政治家们正确地执行了计算，即，T'与更新后键的新值和未修改键的旧树T一致。我们实现这一点的方式是，在某个级别上拆解T’，这一级别称为边界级别（该级别上的节点是边界节点）。公民从政治家的安全样本中获得T'的边界节点值。然后公民们运行一个抽样检查算法——他们随机挑选一个边界节点子集，并要求一个政治家证明该边界节点的正确性。接下来，公民在其他被选中政治家的帮助下创建异常列表。这个列表表示哪些边界节点与公民不一致。公民接着依次纠正不正确的边界节点，然后最终从边界节点计算出T'的正确根。

**证明概述：**在完整的论文中，我们（在引理6中）证明了对于一个好公民，在成功抽查了$\mu$部分的键值后，只有(一小部分)$\tau$个值是不正确的，概率为$1-\varepsilon_1$(其中是$\mu$，$\tau$和$\varepsilon_1$是适当选择的参数)。而且，这些值可通过处理大小不超过$\tau$的异常列表得到修正。因此，一个好公民得到正确值的概率是$1-\varepsilon_1$(推论3)。我们选择的参数(引理7)使得在读取过程中，最多有18名好公民会得到错误值，并在委员会中将它们视为坏公民，算作对它们的处理。在写协议中，我们可以证明异常列表的大小是有界的(引理8)，并且不超过18个公民会接受更新错误的Merkle树T'(引理9)，我们再次将其归到坏公民的集合中。此外，我们还表明，在全局状态读写方面，我们的算法比朴素算法的通信效率提高3\~18倍，计算速度提高10\~66倍。



## 7 安全性、活跃性和公平性的证明

在本节中，我们对Blockene的安全性、活跃性和公平性保证在完整论文中的证明进行了简要概述。

在一个新的区块被签署并且被N委员会成员中阈值数量（$T^*$）的人提交时，第N轮委员会结束。$T^*$将被设置为850(考虑到任意委员会中坏公民的最大数量，以及有36个好公民可能读/写了错误的全局状态)。

首先，我们证明(在引理10中)，对于一个区块，如果一个好公民是胜出提案者，那么(除了有限的常数概率)所有的好公民将输出这个公民的提议作为共识协议的输出。在引理11中，我们证明，相反地，如果一个恶意的公民是获胜者，并且共识结果是一个非空值，那么所有的好公民就都能够下载提案中提交的交易。利用引理7和9(见$\S6中的$证明概述)，我们随后可以证明(引理12)，在区块提交协议的最后，除了36人之外的所有好公民都将签署相同的块散列和新的全局状态根，并且新区块与整个区块链和全局状态是一致的。现在，使用引理12，安全性(即所有诚实的公民都同意所有提交的块，并且所有区块都与一个正确的交易序列一致)通过一个归纳论证得到验证。接下来，为了论证活跃性(敌对实体不能无限期地拖延系统，并且空块概率受到一个小常数的限制)，我们使用引理12和10。

此外，我们还在引理13中证明了吞吐量的界限(在设想中，已提交的块内存在一个交易数量的阈值)，并在引理14中证明了公平性(所有有效的交易最终都会被提交)。



## 8 实现

我们已经构建了Blockene的原型，它分布在两类组件上，公民节点和政治家节点。

### 8.1 公民节点

公民节点是在SDK v23上作为一个Android应用程序实现的，有10200行代码。它是为了优化电池使用而构建的，作为后台应用程序运行，在初始设置后无需用户参与。该应用程序满足公民参与的协议的两个主要阶段:被动和主动。在被动阶段，使用作业调度程序[9]的服务定期轮询政客的getLedger调用。在活动阶段，当公民是委员会的一部分时，应用程序运行协议的步骤，处理失败、超时和重试来处理腐败的政客。活动阶段的实现使用一个多线程事件驱动模型，并建立在EventBus之上，以并行化、流水线网络和计算密集的加密任务，如签名验证。

### 8.2 政治家节点

政治家节点是用c++实现的(11K行代码)。该实现可扩展到成千上万的用户，并在闲聊期间处理突发负载。考虑到协议的状态机特性，我们将其构建在方便的c - actor框架[16]之上，[16]基于通过协议步骤过渡政治家状态的“actor”。例如，BBA演员，除了存储和服务公民提交的投票，还阅读投票，以确定共识的结果。基于此，它发出一个事件来构建更新后的Merkle树。

对于全局状态，我们已经构建了一个SparseMerkleTree (SMT)，其中叶索引是使用密钥的SHA256确定地计算的。因为树的深度是有限的，所以我们允许叶子中的(少量)碰撞。任何键的挑战路径包括与该键同时存在的所有冲突，因此可以计算叶哈希。为了防止单个叶节点的定向溢出，我们拒绝使一个叶节点超过阈值的键添加，迫使事务发起者使用不同的键。我们还实现了一个DeltaMerkleTree，它允许我们使用仅与触摸键成比例的内存高效地创建SMT的更新版本。

我们的八卦实现对常规消息进行简单的广播，并为tx_pool八卦运行一个有状态协议。我们将这些消息隔离到不同的端口/队列中，这样突发的八卦消息就与广播的小消息(例如BBA投票)隔离了。为了防止恶意的公民让诚实的政治家担负起在他们的文章中散布流言蜚语的责任，我们限制了政治家的集合，让公民基于VRF具有确定性。政客们不会从不符合标准的公民那里散布流言蜚语。



## 9 评估

我们在几个维度上评估我们的blockene原型。我们在评估中回答的主要问题是:

- Blockene提供怎样的吞吐量及延迟？
- Blockene处理恶意行为的效果如何？
- 对于默克尔树和八卦的优化是否有效？
- 公民节点上的负载（电池、数据开销）如何？

### 9.1 实验设置

在我们的实验中，我们使用了一个包含2000个公民节点和200个政治家节点的设置。公民节点是在Azure上的一核虚拟机，Xeon E5-2673, 2GB RAM，分布在WAN上的三个地理区域:SouthCentralUS 700 vm, WestUS 600 vm, Eas- tUS 700 vm。每个公民运行的是安卓7.1镜像，并且速率限制为1MB/s网络上传和下载。political节点运行在8核的Azure vm上，Xeon E5-2673, 32 GB RAM，在EastUS和WestUS分别作为100个vm分布。它们的速率被限制为40MB/s的网络带宽。在安全随机抽样的情况下，公民-政治家的交流跨越WAN地区。同样，政客之间的八卦也发生在各地。由于我们委员会的人数是2000人，每个市民都在每个街区的委员会任职。如果公民人数增加，比如100万，那么每500个街区就会有一个特定的公民进入委员会。除了每个公民的负载外，系统性能与公民总数无关，只是委员会规模的函数，所以这些数字代表了一个大的设置。

### 9.2 交易吞吐量与延迟

图2显示了在完全诚实和恶意配置下，block - ene中提交50个连续块的时间线。在完全诚实(0/0)的情况下，4403秒内提交了460万个事务，对应的吞吐量为每秒1045个事务，即114 KB/s。

我们也在公民和政客的恶意行为下评估Blockene。我们用P/C格式表示我们的恶意配置，其中P是恶意政客的比例，C是恶意公民的比例。通过我们选择的参数(例如，委员会规模)，Blockene保证在高达80%的恶意政客和25%的恶意公民存在时确保安全。然而广告行为会影响表现。在这些实验中，一个恶意公民通过两种方式攻击(A)通过与恶意政客勾结来强制一个空块，并提出一个只有恶意政客拥有的tx_pools块。因此，诚实的公民无法下载这个承诺，他们会投票给一个空街区;(b)通过操纵其投票，迫使BBA共识协议进行更多回合谈判。一个恶意的政客通过两种方式进行攻击:(A)无法给出交易承诺，使得45个tx_pools的一个子集为空，可能导致提交一个更小的块;(b)操纵八卦，作为sink holes，向多个对等体请求相同的块。如图2所示，Blockene对于各种恶意行为都非常健壮，并且性能会很好地降低。80%的政客不诚实，有效的tx_pools减少到45个中的9个，导致区块只有18K的交易，而不是90K。当他们被选为提议者时，恶意公民会造成一个性能打击(空块+ BBA回合)。,最高的多联机);表2显示了更多恶意行为配置下的吞吐量。

图3显示了不同配置下系统事务延迟的CDF，演示了跨事务的公平性。在完全诚实的情况下(0/0)，Blockene确保了135秒的中位延迟和263秒的99% -ile延迟。在两个恶意配置:50/10和80/20下，延迟比预期的要高。

### 9.3 公民与政治家的时间表

图4显示了10个区块(每个重复模式都是一个区块)期间一个典型的政治节点的网络负载。上传数据的两个大峰值对应于这个政客是45个被选来提供tx_pools之一的回合。对于每个块，有两个传输数据的小峰值;第一个高峰对应于通过优先八卦tx_pools的八卦，第二个高峰是由于BBA共识中公民投票的八卦。

我们还展示了89秒块延迟的分解，通过绘制一个典型块中公民节点所花费的时间。图5显示了其中一个区块中2000个公民节点的进度，分离出了协议的关键阶段;大部分时间用于事务验证阶段，以及从政客那里获取tx_pool。

### 9.4 优化影响

我们现在评估优先级流言和基于抽样的Merkle树优化。对于八卦，我们考虑在所有其他诚实的政客获得所有tx_pools之前，每个政客需要多少上传/下载。例如，在0/0的情况下，我们有10K数据点(跨越50个区块和每个200个政客)。在这些样本中，我们绘制了第50、90和99个百分位数。我们在80/25案例中建模的恶意策略是，只有最低数量的诚实公民拥有恶意政客的tx_pool(∆，§5.5.2)，所有恶意政客从所有诚实节点请求tx_pool的完整集合。如表3所示，优先八卦的网络负载对不诚实行为具有鲁棒性。即使在恶意设置中，在所有诚实的政客获得所有tx_pool之前，传输的数据也相当少。

表4比较了我们基于Merkle-tree读取和更新的采样的性能，以及为块中引用的所有键下载挑战路径的简单解决方案。简单的解决方案会招致更高的网络成本(这些数字是在gRPC压缩后产生的)，以及在公民身上的巨大计算成本。经过我们的优化，网络成本下降了10.8×， CPU成本下降了近31×，从而显著提高了事务吞吐量。

### 9.5 公民的负荷

最后，我们评估公民节点由于运行Blockene的负载。两个感兴趣的指标是电池使用量和数据使用量。为了获得这些指标，我们运行了一款带有公民应用的实际Android手机(一加5)，作为委员会的一部分，以及vm上的2000名委员会成员，并测量电池的使用。在委员会工作5个街区后，电池耗电量约为3%。公民对单个块产生的总网络流量为19.5 MB。

现在，我们可以根据每块成本和每个公民预计进入委员会的次数来推算每天的成本。在100万公民中，大约每500个区块就会有一个公民参与，在我们的区块延迟约90秒的情况下，也就是每天2次。因此，预计电池使用量每天小于2%，数据使用量为~40MB/天。此外，我们还在OnePlus5上进行了测试，每10分钟叫醒一次手机，执行getLedger需要消耗0.9%的电池和21MB的下载数据。每5分钟醒来需要消耗1.7%的电池和42MB的数据下载。在总共3%的电量和每天61MB的数据下，运行Blockene应用的用户几乎不会注意到它的运行。



## 10 结论

Blockene首次实现了高吞吐量的区块链，成员能在可忽略不计的资源使用下在智能手机上进行区块验证和共识，从而开拓了更大的一类现实应用程序，它们能够受益于区块链的安全性和去中心性。结合一种新颖的架构、几种新技术以及谨慎的安全推理，Blockene能够同时提供三个冲突的属性：大规模参与、高事务吞吐量和成员节点的低资源使用。